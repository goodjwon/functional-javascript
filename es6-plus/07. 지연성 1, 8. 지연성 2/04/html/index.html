<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>L.flatten</title>
    <script src="../js/fx.js"></script>
</head>
<body>

    <script>

        log([...[1,2],3,4, ...[5,6],7,8,9])

        const isIterable = a => a && a[Symbol.iterator]

        L.flatten = function *(iter) {

            for(const a of iter){
                if(isIterable(a)) for(const b of a) yield b
                else yield a
            }
        }

        var it = L.flatten([[1,2],3,4, [5,6],7,8,9])

        log(take(4, L.flatten([[1,2],3,4, [5,6],7,8,9])))

        log(it.next());

        log(...it);

        const flatten = pipe(L.flatten, takeAll)

        log(flatten([[1,2],3,4, [5,6],7,8,9]))

    </script>


    ## yield *

    <script>
        L.flatten = function *(iter) {
            for (const a of iter) {
                if (isIterable(a)) for (const b of a) yield b
                else yield a;
            }
        };
    </script>

    `yield *`을 활용하면 위 코드를 아래와 같이 변경할 수 있습니다. `yield *iterable`은 `for (const val of iterable) yield val;` 과 같습니다.

    <script>
        L.flatten = function *(iter) {
            for (const a of iter) {
                if (isIterable(a)) yield *a;
                else yield a;
            }
        };
    </script>

    ## L.deepFlat

    만일 깊은 Iterable을 모두 펼치고 싶다면 아래와 같이 `L.deepFlat`을 구현하여 사용할 수 있습니다. `L.deepFlat`은 깊은 Iterable을 펼쳐줍니다.

    <script>
        L.deepFlat = function *f(iter) {
            for (const a of iter) {
                if (isIterable(a)) yield *f(a);
                else yield a;
            }
        };
        log([...L.deepFlat([1, [2, [3, 4], [[5]]]])]);
        // [1, 2, 3, 4, 5];
    </script>

    ## L.flatMap

    <script>
        // log([[1, 2], [3, 4], [5, 6, 7]].flatMap(a => a));
        // log([[1, 2], [3, 4], [5, 6, 7]].flatMap(a => a.map(a => a * a)));
        // log(flatten([[1, 2], [3, 4], [5, 6, 7]].map(a => a.map(a => a * a))));
        // log(flatten([[1, 2], [3, 4], [5, 6, 7]].map(a => a.map(a => a * a))));
        L.flatMap = curry(pipe(L.map, L.flatten));
        const flatMap = curry(pipe(L.map, flatten));
        // var it = L.flatMap(map(a => a * a), [[1, 2], [3, 4], [5, 6, 7]]);
        var it = L.flatMap(a => a, [[1, 2], [3, 4], [5, 6, 7]]);
        log([...it]);
        // log(it.next());
        // log(it.next());
        // log(it.next());
        // log(it.next());
        // log(it.next());
        // log(it.next());
        // log(it.next());
        log(flatMap(a => a, [[1, 2], [3, 4], [5, 6, 7]]));
        log(flatMap(L.range, map(a => a + 1, [1, 2, 3])));
        var it = L.flatMap(L.range, map(a => a + 1, [1, 2, 3]));
        log(it.next());
        log(it.next());
        log(it.next());
        log(it.next());
        log(take(3, L.flatMap(L.range, map(a => a + 1, [1, 2, 3]))));
        console.clear();
    </script>


    ## 2차원 배열 다루기

    <script>
        const arr = [
            [1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [9, 10]
        ];
        go(arr,
            L.flatten,
            L.filter(a => a % 2),
            L.map(a => a * a),
            //take(4),
            takeAll,
            reduce(add),
            log);
    </script>


</body>
</html>